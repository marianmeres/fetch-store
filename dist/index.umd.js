!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["fetch-store"]={})}(this,(function(e){"use strict";const t=e=>"function"==typeof e,r=(e,r="")=>{if(!t(e))throw new TypeError(`${r} Expecting function arg`.trim())},s=e=>t(e.subscribe),n=(e,s=null)=>{const n=e=>t(s?.persist)&&s.persist(e);let c=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r)=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const s=r(e,(e=>{t(e),s()}));return s},unsubscribeAll:t=>e.delete(t)}})(),l=e;n(l);const i=()=>l,a=e=>{l!==e&&(l=e,n(l),c.publish("change",l))};return{set:a,get:i,update:e=>{r(e,"[update]"),a(e(i()))},subscribe:e=>(r(e,"[subscribe]"),e(l),c.subscribe("change",e))}},c={fetchOnceDefaultThresholdMs:3e5,isEqual:(e,t)=>e===t};e.createFetchStore=(e,l=null,i=null,a={})=>{const{fetchOnceDefaultThresholdMs:o,isEqual:u}={...c,...a||{}},h=(e,t)=>"function"==typeof i?i?.(e,t):e,f=n(h(l),a),g=n({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null,lastFetchSilentError:null,successCounter:0}),{subscribe:b,get:E}=((e,c,l=null)=>{const i=e=>t(l?.persist)&&l.persist(e),a=n(l?.initialValue),o=[];if(e.forEach((e=>{if(!s(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>o.push(e)))()})),!t(c))throw new TypeError("Expecting second argument to be the derivative function");if(!c.length||c.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let u=0,h=[];return{get:a.get,subscribe:t=>{r(t,"[derived.subscribe]"),u++||e.forEach(((e,t)=>{h.push(e.subscribe((e=>{o[t]=e,1===c.length?(a.set(c(o)),i(a.get())):c(o,(e=>{a.set(e),i(a.get())}))})))}));const s=a.subscribe(t);return()=>{--u||(h.forEach((e=>e())),h=[]),s()}}}})([f,g],(([e,t])=>({data:e,...t})));b((()=>null));const d=async(...t)=>{let r=g.get();r.isFetching=!0,r.lastFetchStart=new Date,r.lastFetchEnd=null,r.lastFetchError=null,g.set({...r});try{f.set(h(await e(...t),f.get())),r.successCounter++}catch(e){r.lastFetchError=e}finally{r.isFetching=!1,r.lastFetchEnd=new Date}return g.set({...r}),g.get().lastFetchError?null:f.get()},p=async(...t)=>{let r=g.get(),s=0;r.lastFetchSilentError&&(g.set({...r,lastFetchSilentError:null}),s++);try{f.set(h(await e(...t),f.get()))}catch(e){r.lastFetchSilentError=e,s++}return s&&g.set({...r}),g.get().lastFetchSilentError?null:f.get()};let F;const y=(e=[],t=500)=>(Array.isArray(e)||(e=[e]),p(...e).then((()=>{if(!1===F)return F=void 0;F&&(clearTimeout(F),F=void 0),F=setTimeout((()=>y(e,t)),t)})),()=>{F?(clearTimeout(F),F=void 0):F=!1});return{subscribe:b,get:E,fetch:d,fetchSilent:p,fetchOnce:async(e=[],t=o)=>{const{successCounter:r,isFetching:s,lastFetchStart:n}=g.get();return Array.isArray(e)||(e=[e]),r||s?t&&!s&&n&&Date.now()-new Date(n).valueOf()>t?await d(...e):f.get():await d(...e)},fetchRecursive:y,reset:()=>{f.set(h(l)),g.set({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null,lastFetchSilentError:null,successCounter:0})},resetError:()=>g.update((e=>({...e,lastFetchError:null}))),getInternalDataStore:()=>f,fetchWorker:e}}}));
