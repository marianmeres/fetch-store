"use strict";const t=t=>"function"==typeof t,e=(e,r="")=>{if(!t(e))throw new TypeError(`${r} Expecting function arg`.trim())},r=e=>t(e.subscribe),n=(r,n=null)=>{const s=e=>t(n?.persist)&&n.persist(e);let c=(()=>{const t=new Map,e=e=>(t.has(e)||t.set(e,new Set),t.get(e)),r=(t,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return e(t).add(r),()=>e(t).delete(r)};return{publish:(t,r)=>{e(t).forEach((t=>t(r)))},subscribe:r,subscribeOnce:(t,e)=>{const n=r(t,(t=>{e(t),n()}));return n},unsubscribeAll:e=>t.delete(e)}})(),l=r;s(l);const a=()=>l,u=t=>{l!==t&&(l=t,s(l),c.publish("change",l))};return{set:u,get:a,update:t=>{e(t,"[update]"),u(t(a()))},subscribe:t=>(e(t,"[subscribe]"),t(l),c.subscribe("change",t))}},s=(s,c,l=null)=>{const a=e=>t(l?.persist)&&l.persist(e),u=n(l?.initialValue),o=[];if(s.forEach((t=>{if(!r(t))throw new TypeError("Expecting array of StoreLike objects");t.subscribe((t=>o.push(t)))()})),!t(c))throw new TypeError("Expecting second argument to be the derivative function");if(!c.length||c.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let i=0,h=[];return{get:u.get,subscribe:t=>{e(t,"[derived.subscribe]"),i++||s.forEach(((t,e)=>{h.push(t.subscribe((t=>{o[e]=t,1===c.length?(u.set(c(o)),a(u.get())):c(o,(t=>{u.set(t),a(u.get())}))})))}));const r=u.subscribe(t);return()=>{--i||(h.forEach((t=>t())),h=[]),r()}}}},c=t=>"function"==typeof t,l={},a={fetchOnceDefaultThresholdMs:3e5},u=t=>"function"==typeof t;exports.createFetchStore=(t,e=null,r=null,c={})=>{const{fetchOnceDefaultThresholdMs:l}={...a,...c||{}},o=(t,e)=>u(r)?r?.(t,e):t,i=n(o(e),c),h=n({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null,successCounter:0,lastFetchSilentError:null}),{subscribe:g,get:F}=s([i,h],(([t,e])=>({data:t,...e})));g((()=>null));const E=async(...e)=>{let r=h.get();r.isFetching=!0,r.lastFetchStart=new Date,r.lastFetchEnd=null,r.lastFetchError=null,h.set({...r});try{i.set(o(await t(...e),i.get())),r.successCounter++}catch(t){r.lastFetchError=t}finally{r.isFetching=!1,r.lastFetchEnd=new Date}return h.set({...r}),h.get().lastFetchError?null:i.get()},f=async(...e)=>{let r=h.get(),n=0;r.lastFetchSilentError&&(h.set({...r,lastFetchSilentError:null}),n++);try{i.set(o(await t(...e),i.get()))}catch(t){r.lastFetchSilentError=t,n++}return n&&h.set({...r}),h.get().lastFetchSilentError?null:i.get()},b=(t=[],e=500)=>{let r,n=!1;return((t=[],e=500)=>{Array.isArray(t)||(t=[t]);const s=u(e)?e():e;return f(...t).then((()=>{r&&clearTimeout(r),s>0&&!n&&(r=setTimeout((()=>!n&&b(t,s)),s))})),()=>{r&&clearTimeout(r),n=!0}})(t,e)};return{subscribe:g,get:F,fetch:E,fetchSilent:f,fetchOnce:async(t=[],e=l)=>{const{successCounter:r,isFetching:n,lastFetchStart:s}=h.get();return Array.isArray(t)||(t=[t]),r||n?e&&!n&&s&&Date.now()-new Date(s).valueOf()>e?await E(...t):i.get():await E(...t)},fetchRecursive:b,reset:()=>{i.set(o(e)),h.set({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null,successCounter:0,lastFetchSilentError:null})},resetError:()=>h.update((t=>({...t,lastFetchError:null}))),getInternalDataStore:()=>i,fetchWorker:t}},exports.createFetchStreamStore=(t,e=null,r=null,a={})=>{a={...l,...a||{}};const u=(t,e)=>c(r)?r?.(t,e):t,o=n(u(e),a),i=n({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null}),{subscribe:h,get:g}=s([o,i],(([t,e])=>({data:t,...e})));h((()=>null));return{subscribe:h,get:g,fetchStream:(e=[],r=0)=>{let n,s=!1;const l=(e=[],r=0)=>{Array.isArray(e)||(e=[e]);const a=c(r)?r():r;let h;i.update((t=>({...t,isFetching:!0,lastFetchStart:new Date,lastFetchEnd:null,lastFetchError:null})));try{h=t(((t,r)=>{i.get().lastFetchError&&i.update((t=>({...t,lastFetchError:null}))),"data"===t?o.set(u(r,o.get())):"error"===t?i.update((t=>({...t,lastFetchError:r}))):"end"===t&&(i.update((t=>({...t,isFetching:!1,lastFetchEnd:new Date}))),a>0&&!s&&(n&&clearTimeout(n),n=setTimeout((()=>!s&&l(e,a)),a)))}),...e)}catch(t){i.update((e=>({...e,lastFetchError:t})))}return()=>{"function"==typeof h?h():console.warn("`abort` is a noop (the fetchStreamWorker did not return a function)."),n&&clearTimeout(n),s=!0}};return l(e,r)},reset:()=>{o.set(u(e)),i.set({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null})},resetError:()=>i.update((t=>({...t,lastFetchError:null}))),getInternalDataStore:()=>o,fetchStreamWorker:t}};
