"use strict";const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=t=>e(t.subscribe),s=(r=void 0,s=null)=>{const n=t=>e(s?.persist)&&s.persist(t);let c=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r)=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const s=r(e,(e=>{t(e),s()}));return s},unsubscribeAll:t=>e.delete(t)}})(),a=r;n(a);const l=()=>a,o=e=>{a!==e&&(a=e,n(a),c.publish("change",a))};return{set:o,get:l,update:e=>{t(e,"[update]"),o(e(l()))},subscribe:e=>(t(e,"[subscribe]"),e(a),c.subscribe("change",e))}},n={fetchOnceDefaultThresholdMs:3e5},c=e=>"function"==typeof e;exports.createFetchStore=(a,l=null,o=null,i=null)=>{const{logger:u,onError:h,onSilentError:b,afterCreate:g,fetchOnceDefaultThresholdMs:f}={...n,...i||{}},p=(e,t)=>c(o)?o(e,t):e,d=s(p(l)),E=s({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null,successCounter:0}),{subscribe:w,get:F}=((n,c,a=null)=>{const l=t=>e(a?.persist)&&a.persist(t),o=s(a?.initialValue),i=[];if(n.forEach((e=>{if(!r(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>i.push(e)))()})),!e(c))throw new TypeError("Expecting second argument to be the derivative function");if(!c.length||c.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let u=0,h=[];return{get:o.get,subscribe:e=>{t(e,"[derived.subscribe]"),u++||n.forEach(((e,t)=>{h.push(e.subscribe((e=>{i[t]=e,1===c.length?(o.set(c(i)),l(o.get())):c(i,(e=>{o.set(e),l(o.get())}))})))}));const r=o.subscribe(e);return()=>{--u||(h.forEach((e=>e())),h=[]),r()}}}})([d,E],(([e,t])=>({data:e,...t})));w((()=>null));const y=async(...e)=>{let t=d.get(),r=E.get();const s=new Date;let n=null;E.set({...r,isFetching:!0,lastFetchStart:s,lastFetchEnd:null,lastFetchError:n});try{t=p(await a(...e),t),r.successCounter++}catch(e){n=e}return d.set(t),E.set({...r,isFetching:!1,lastFetchStart:s,lastFetchEnd:new Date,lastFetchError:n}),n&&c(h)&&h(n),t},S={subscribe:w,get:F,fetch:y,fetchSilent:async(...e)=>{try{let t=p(await a(...e),d.get());return d.set(t),t}catch(e){((...e)=>{c(u)&&u.apply(null,e)})("silent fetch error",e),c(b)&&b(e)}},fetchOnce:async(e=[],t=f)=>{const{successCounter:r,isFetching:s,lastFetchStart:n}=E.get();return Array.isArray(e)||(e=[e]),r||s?t&&!s&&n&&Date.now()-new Date(n).valueOf()>t?await y(...e):void 0:await y(...e)},reset:()=>{d.set(p(l)),E.set({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null,successCounter:0})},resetError:()=>E.update((e=>({...e,lastFetchError:null}))),getInternalDataStore:()=>d};return c(g)&&(console?.warn?.("`afterCreate` option is deprecated and will be removed"),g(S)),S};
