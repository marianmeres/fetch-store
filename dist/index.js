const t=t=>"function"==typeof t,e=(e,r="")=>{if(!t(e))throw new TypeError(`${r} Expecting function arg`.trim())},r=e=>t(e.subscribe),s=(r,s=null)=>{const n=e=>t(s?.persist)&&s.persist(e);let a=(()=>{const t=new Map,e=e=>(t.has(e)||t.set(e,new Set),t.get(e)),r=(t,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return e(t).add(r),()=>e(t).delete(r)};return{publish:(t,r)=>{e(t).forEach((t=>t(r)))},subscribe:r,subscribeOnce:(t,e)=>{const s=r(t,(t=>{e(t),s()}));return s},unsubscribeAll:e=>t.delete(e)}})(),l=r;n(l);const c=()=>l,i=t=>{l!==t&&(l=t,n(l),a.publish("change",l))};return{set:i,get:c,update:t=>{e(t,"[update]"),i(t(c()))},subscribe:t=>(e(t,"[subscribe]"),t(l),a.subscribe("change",t))}},n={fetchOnceDefaultThresholdMs:3e5,isEqual:(t,e)=>t===e},a=(a,l=null,c=null,i={})=>{const{fetchOnceDefaultThresholdMs:u,isEqual:o}={...n,...i||{}},h=(t,e)=>"function"==typeof c?c?.(t,e):t,g=s(h(l),i),E=s({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null,successCounter:0,lastFetchSilentError:null,isStreaming:!1,lastFetchStreamStart:null,lastFetchStreamEnd:null,lastFetchStreamError:null}),{subscribe:f,get:d}=((n,a,l=null)=>{const c=e=>t(l?.persist)&&l.persist(e),i=s(l?.initialValue),u=[];if(n.forEach((t=>{if(!r(t))throw new TypeError("Expecting array of StoreLike objects");t.subscribe((t=>u.push(t)))()})),!t(a))throw new TypeError("Expecting second argument to be the derivative function");if(!a.length||a.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let o=0,h=[];return{get:i.get,subscribe:t=>{e(t,"[derived.subscribe]"),o++||n.forEach(((t,e)=>{h.push(t.subscribe((t=>{u[e]=t,1===a.length?(i.set(a(u)),c(i.get())):a(u,(t=>{i.set(t),c(i.get())}))})))}));const r=i.subscribe(t);return()=>{--o||(h.forEach((t=>t())),h=[]),r()}}}})([g,E],(([t,e])=>({data:t,...e})));f((()=>null));const F=async(...t)=>{let e=E.get();e.isFetching=!0,e.lastFetchStart=new Date,e.lastFetchEnd=null,e.lastFetchError=null,E.set({...e});try{g.set(h(await a(...t),g.get())),e.successCounter++}catch(t){e.lastFetchError=t}finally{e.isFetching=!1,e.lastFetchEnd=new Date}return E.set({...e}),E.get().lastFetchError?null:g.get()},S=async(...t)=>{let e=E.get(),r=0;e.lastFetchSilentError&&(E.set({...e,lastFetchSilentError:null}),r++);try{g.set(h(await a(...t),g.get()))}catch(t){e.lastFetchSilentError=t,r++}return r&&E.set({...e}),E.get().lastFetchSilentError?null:g.get()};let b;const p=(t=[],e=500)=>(Array.isArray(t)||(t=[t]),S(...t).then((()=>{if(!1===b)return b=void 0;b&&(clearTimeout(b),b=void 0),b=setTimeout((()=>p(t,e)),e)})),()=>{b?(clearTimeout(b),b=void 0):b=!1});let m;const w=async(t=[],e=0)=>{let r;Array.isArray(t)||(t=[t]),E.update((t=>({...t,isStreaming:!0,lastFetchStreamStart:new Date,lastFetchStreamEnd:null,lastFetchStreamError:null})));let s=()=>{"function"==typeof r?r():console.warn("This is a noop as the fetchWorker did not return a function."),m?(clearTimeout(m),m=void 0):m=!1};try{r=await a(((r,n)=>{if(r=`${r||""}`.toLowerCase(),E.get().lastFetchStreamError&&E.update((t=>({...t,lastFetchStreamError:null}))),"data"===r)g.set(h(n,g.get()));else if("error"===r)E.update((t=>({...t,lastFetchStreamError:n})));else if("end"===r&&(E.update((t=>({...t,isStreaming:!1,lastFetchStreamEnd:new Date}))),e>0)){if(!1===m)return m=void 0;m&&(clearTimeout(m),m=void 0),m=setTimeout((async()=>{s=await w(t,e)}),e)}}),...t)}catch(t){E.update((e=>({...e,lastFetchStreamError:t})))}return s};return{subscribe:f,get:d,fetch:F,fetchSilent:S,fetchOnce:async(t=[],e=u)=>{const{successCounter:r,isFetching:s,lastFetchStart:n}=E.get();return Array.isArray(t)||(t=[t]),r||s?e&&!s&&n&&Date.now()-new Date(n).valueOf()>e?await F(...t):g.get():await F(...t)},fetchRecursive:p,fetchStream:w,reset:()=>{g.set(h(l)),E.set({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null,successCounter:0,lastFetchSilentError:null,isStreaming:!1,lastFetchStreamStart:null,lastFetchStreamEnd:null,lastFetchStreamError:null})},resetError:()=>E.update((t=>({...t,lastFetchError:null}))),getInternalDataStore:()=>g,fetchWorker:a}};export{a as createFetchStore};
