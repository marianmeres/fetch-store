const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=t=>e(t.subscribe),s=(r,s=null)=>{const n=t=>e(s?.persist)&&s.persist(t);let c=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r)=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const s=r(e,(e=>{t(e),s()}));return s},unsubscribeAll:t=>e.delete(t)}})(),l=r;n(l);const a=()=>l,i=e=>{l!==e&&(l=e,n(l),c.publish("change",l))};return{set:i,get:a,update:e=>{t(e,"[update]"),i(e(a()))},subscribe:e=>(t(e,"[subscribe]"),e(l),c.subscribe("change",e))}},n={fetchOnceDefaultThresholdMs:3e5,isEqual:(e,t)=>e===t},c=(c,l=null,a=null,i={})=>{const{fetchOnceDefaultThresholdMs:u,isEqual:h}={...n,...i||{}},o=(e,t)=>"function"==typeof a?a?.(e,t):e,g=s(o(l),i),b=s({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null,lastFetchSilentError:null,successCounter:0,hasChangedSinceLastFetch:!1}),{subscribe:f,get:E}=((n,c,l=null)=>{const a=t=>e(l?.persist)&&l.persist(t),i=s(l?.initialValue),u=[];if(n.forEach((e=>{if(!r(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>u.push(e)))()})),!e(c))throw new TypeError("Expecting second argument to be the derivative function");if(!c.length||c.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let h=0,o=[];return{get:i.get,subscribe:e=>{t(e,"[derived.subscribe]"),h++||n.forEach(((e,t)=>{o.push(e.subscribe((e=>{u[t]=e,1===c.length?(i.set(c(u)),a(i.get())):c(u,(e=>{i.set(e),a(i.get())}))})))}));const r=i.subscribe(e);return()=>{--h||(o.forEach((e=>e())),o=[]),r()}}}})([g,b],(([e,t])=>({data:e,...t})));f((()=>null));let F=l;const p=e=>{let t;return"function"==typeof h&&(t=!h(F,e)),F=e,t},d=async(...e)=>{let t=b.get();t.isFetching=!0,t.lastFetchStart=new Date,t.lastFetchEnd=null,t.lastFetchError=null,b.set({...t});try{g.set(o(await c(...e),g.get())),t.successCounter++}catch(e){t.lastFetchError=e}finally{t.isFetching=!1,t.lastFetchEnd=new Date}return b.set({...t,hasChangedSinceLastFetch:p(g.get())}),b.get().lastFetchError?null:g.get()};let y=0;const w=(e=[],t=500)=>{const{isFetching:r}=b.get();Array.isArray(e)||(e=[e]),-1===y&&(y=0);const s=()=>{y>0&&clearTimeout(y),y=setTimeout((()=>{-1!==y&&w(e,t)}),t)};return r?s():d(...e).then(s),()=>{y?(clearTimeout(y),y=0):y=-1}},S={subscribe:f,get:E,fetch:d,fetchSilent:async(...e)=>{let t=b.get();t.lastFetchSilentError&&b.set({...t,lastFetchSilentError:null});try{g.set(o(await c(...e),g.get()))}catch(e){t.lastFetchSilentError=e}return b.set({...t,hasChangedSinceLastFetch:p(g.get())}),b.get().lastFetchSilentError?null:g.get()},fetchOnce:async(e=[],t=u)=>{const{successCounter:r,isFetching:s,lastFetchStart:n}=b.get();return Array.isArray(e)||(e=[e]),r||s?t&&!s&&n&&Date.now()-new Date(n).valueOf()>t?await d(...e):g.get():await d(...e)},fetchRecursive:w,reset:()=>{g.set(o(l)),b.set({isFetching:!1,lastFetchStart:null,lastFetchEnd:null,lastFetchError:null,lastFetchSilentError:null,successCounter:0,hasChangedSinceLastFetch:!1})},resetError:()=>b.update((e=>({...e,lastFetchError:null}))),getInternalDataStore:()=>g,fetchWorker:c};return S};export{c as createFetchStore};
